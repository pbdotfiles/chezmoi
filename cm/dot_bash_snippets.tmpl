#--- Add a "tempwork" command that creates a temporary directory that will be automatically deleted after exit.
tempwork() {
  local tdir
  tdir=$(mktemp -d)
  # Open a new sub-shell inside the temp directory
  (
    cd "$tdir" || return
    echo "Entering temporary workspace: $tdir"
    echo "This directory will be deleted when you type 'exit'."
    $SHELL
    rm -rf "$tdir"
    echo "Workspace $tdir deleted."
  )
}


#--- Tmux utility
# Create, attach, or switch to a tmux session by name from both inside or outside tmux.
# Usage: tm <session-name>

tm() {
  # 1. Check if a session name was provided
  if [ -z "$1" ]; then
    echo "Usage: tm <session-name>"
    return 1
  fi

  # 2. Check if the session already exists
  tmux has-session -t "$1" 2>/dev/null
  local session_exists=$?

  # 3. Create the session if it doesn't exist
  if [ $session_exists -ne 0 ]; then
    tmux new-session -d -s "$1"
    echo "Created new session: $1"
  fi

  # 4. Logic for switching/attaching
  if [ -n "$TMUX" ]; then
    # We are INSIDE tmux
    local current_session=$(tmux display-message -p '#S')

    if [ "$current_session" = "$1" ]; then
      echo "You are already in session: $1"
    else
      tmux switch-client -t "$1"
    fi
  else
    # We are OUTSIDE tmux
    tmux attach-session -t "$1"
  fi
}

# Add tab autocomplete for the "tm" command
_tm_completion() {
    local cur=${COMP_WORDS[COMP_CWORD]}
    # Get list of sessions, removing the trailing colon from tmux output
    local sessions=$(tmux list-sessions -F "#S" 2>/dev/null)
    COMPREPLY=( $(compgen -W "$sessions" -- "$cur") )
}
complete -F _tm_completion tm

#--- BTRFS snippet to change Copy-on-Write status
function set_cow_mode() {
    local target="$1"
    local mode="$2"  # Expect "cow" or "nocow"
    
    # --- 1. Validation ---
    if [ -z "$target" ] || [ -z "$mode" ]; then
        echo "Usage: set_cow_mode <directory_path> <cow|nocow>"
        return 1
    fi
    
    # Remove trailing slash
    target="${target%/}"

    if [ ! -d "$target" ]; then
        echo "Error: '$target' is not a directory."
        return 1
    fi

    if [[ "$mode" != "cow" && "$mode" != "nocow" ]]; then
        echo "Error: Mode must be 'cow' or 'nocow'."
        return 1
    fi

    local temp_target="${target}_TEMP_CONVERSION"
    local backup_target="${target}_OLD_BACKUP"

    echo "--- Converting '$target' to mode: $mode ---"

    # --- 2. Create Temp Directory ---
    mkdir -p "$temp_target"
    
    # Apply Attributes based on mode
    if [ "$mode" == "nocow" ]; then
        chattr +C "$temp_target"
        # Verify C flag is present
        if ! lsattr -d "$temp_target" | awk '{print $1}' | grep -q "C"; then
             echo "Error: Failed to set +C (NoCoW). Is this Btrfs?"
             rmdir "$temp_target"
             return 1
        fi
    else
        # Force Enable CoW (Remove C attribute)
        # We do this explicitly in case the parent folder has +C and we inherited it.
        chattr -C "$temp_target"
        # Verify C flag is NOT present
        if lsattr -d "$temp_target" | awk '{print $1}' | grep -q "C"; then
             echo "Error: Failed to ensure CoW mode (Could not remove +C)."
             rmdir "$temp_target"
             return 1
        fi
    fi

    # --- 3. Copy Data ---
    echo "Copying data... (cp -a --reflink=never)"
    # We use --reflink=never to force a physical rewrite of the data blocks
    # so they adhere to the new directory's attribute.
    cp -a --reflink=never "$target/." "$temp_target/"
    
    if [ $? -ne 0 ]; then
        echo "Error during copy. Aborting. Original data untouched."
        rm -rf "$temp_target"
        return 1
    fi

    # --- 4. Clone Metadata ---
    echo "Cloning ownership, permissions, and timestamps..."
    chown --reference="$target" "$temp_target"
    chmod --reference="$target" "$temp_target"

    # --- 5. Swap ---
    mv "$target" "$backup_target"
    mv "$temp_target" "$target"

    # Verify the swap happened
    if [ -d "$target" ]; then
        echo "Success! '$target' is now $mode."
        rm -rf "$backup_target" 
    else
        echo "CRITICAL ERROR: New folder did not move into place!"
        echo "Check '$temp_target' and '$backup_target'."
        return 1
    fi
}
